
>[!tip] Created: [2025-08-06 Wed 09:24]

>[!question] Targets: 

>[!danger] Depends: 

needs to have a down and up channel, so that the chain it runs can communicate with it, like for changing the validator set.

needs a protocol upgrade point, where at a prearranged point, everyone will upgrade.

needs to do byzantine reporting.
error on duplicate content with a different hash, or a message number incrementing.
This number should be a ulid ? so that if the node loses its memory, it can recover ?
if it loses memory, it has to wait, in case it is acting byzantine.

node not making available the hash contents it says it has.  Each node should get a receipt from its peers when it has finished uploading, to prove that it did indeed make what it said available.

needs a version number in the protocol of each message.

each agreement needs to point at the prior hash that was agreed upon.

could allow one node to rip ahead and propose many different sequences, with each subsequent round referencing the first ?

each function call should be given a seed parameter to, to generate randomness from.  It might choose to generate a random order of broadcast messages to send to different nodes in different orders.

? can this be a public chain, where anyone can join ?

needs to signal to the host application that it has reached agreement on the next hash.
the host would not present it a hash unless it had been checked for availability and correctness, so these messages come in with the fetching being completed already.  If the underlying system cannot fetch the information that it seeks consensus about, then it doesn't bother the consensus mechanism.

The underlying storage mechanism would call byzantine denial faults if something proposed something then didn't make it available.

need some system message types that go in and out of the host, like add validator, remove validator, slash?

the host would send in a message about add validator, which would be taken from the hash that was accepted.

each output should also put out the hash of the state each time, and when this changes, the host might trigger some activity, like modifying the validator groups or weights.

also trigger a protocol version upgrade ? or is that just going to happen by the host calling a new function with the upgrade function, and it gives back the next state, and some messages.  Or, require that the function recognize when it has been upgraded, and it manges the reformatting of the state naturally.  

The host is the one that swaps this out, based on the hostside config.

we should allow a speculative form of consensus where clients can access the proposal, before it is committed, since most likely it is going to be correct.  Also the next commits should be allowed too, so a proposal hash might be many commits in the future, and the network could catch up.

If we do raft for our internal stuff, since it is high frequency, then we use this to build up the primitives we offer.  The interface is identical as to BFT implementation, and the UI visibility is the same too.

internally we could use raft, and then layer on top a BFT syncer, so we don't burden the BFT layer with our crash tolerance requirements.

The api is
```ts
type Consensus = ( message: Message, state: State ) => { next: State; messages: Record<PeerId, Message[]> }
```