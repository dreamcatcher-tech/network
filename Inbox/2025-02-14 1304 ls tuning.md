
>[!tip] Created: [2025-02-14 Fri 13:04]

>[!question] Targets: 

>[!danger] Depends: 

cache the ls lookups based on an oid.

allow ls to be like a readtree function, where we pass in a tree id.

meta() calls could be done starting with an oid rather than the top of the commit stack.

each tree read should start at the oid of the tree it came from, since we know that already.

listDirCached could store calls that were made, and use the oid to make the next call down.
if higher listings hav

overall, the tree should be cached, so that each call would rely on the parent chain, which is what git has to do anyway, so we might as well wait and only do each call once, which will be significantly faster.
So we basically develop our own drill down logic, and store this cache possibly against the commitscope object, as long as it exists, we'll keep using it.

tip.ls(), which is always scoped, should cache any ls requests it receives, and should use the tree object itself to shortcut the listing.  The reason it should stick with linking to commits, is if we expose the ability to look up a tree directly, then a program can gain access to a data that is not part of the current tree, leading to insecurity but also subtle bugs in user programs that will seem puzzling.

Going deeper, the provider ls function could be the one that cached, and did the walk of the trees manually ?  So it would just loop until it got to where the path requested, but it would cache all the meta entries it found so far.  It would walk down from a commit each time.  Multiple concurrent calls would wait for a single call.  Provider would do all the throttling, so tips can just ask as much as they like.

So then, resolveEntry should be the caching thing, that also funnels all callers into a single choke point.  It will just recursively call itself.