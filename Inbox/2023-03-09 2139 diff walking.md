
>[!tip] Created: [2023-03-09 Thu 21:39]

>[!question] Targets: 

>[!danger] Depends: 

Often a lift needs to occur when we already have something relavant.
Lifts are always rooted in pulses, so we start by comparing there.

Make collectionList use the api and lazy loading model to update only when the crisp is known to have changed.  Present skeletons at all other times.

## V1
When walking the children of the pulse, we can try get the same channelId in the prior pulse, knowing that it is stable.  If we do not have any channel, then we know we need it.  If latest is the same, then we return.  If it is different, then it gets submitted as prior.

Takes advantage of the stability of channelIds.

May send down duplicate blocks since no reuse between differing pulses is accounted for.

## V2 use a subtracting resolver
Each pulse we find that is on the same channel but has a different pulseId, uncrush the prior using logging resolver that does not stream down, then uncrush current and only stream when a block that we did not previously have was found.

This can be done as self, hamts, then children.

## V3 intelligent walk
Use hamt compare to get the adds and mods for the nonBakeSkippable hamts.
Once have the diffs, use a logging resolver to stream down the hamt blocks while walking the hamts.
Then, walk the child list to get the pulses that were new, inflate those fully using the loggingResolver.  Walk mods and use a diffing resolver

If the pulses resolver tracked what it loaded, and we could access that in the pulse, we could skip a resolve.
The summary of all pulses since it was first uncrushed should allow us to know if we ever sent a block before, so in the latest uncrush, check with the prior one if we loaded it ?
If each crush also stored the diff of new blocks between it and the last crush ?
Use immutable maps and merge them each time ?
But would it need to be built from scratch during lift, as we might have dropped some blocks ?

Cache the logging resolver outputs, so can quickly do a subtraction to get the diff of later pulses.

## V4 cached full walks
Store an LRU ejecting cache of the blockset of each uncrush.
If the lift request has a cache hit, use this to subtract off the full walk before sending.
If miss, do the full walk and cache it - do first so can stream the next crush as live subtractions.
If both current and prior are cache hits, stream down the subtraction of the blockset.
If prior is a miss, do the full walk and cache it first.
If current is a hit, stream down a subtration with the prior in cache
If current is a miss, build up the
Store the caches as promises, which need to be awaited, in case a parallel request comes in.

Later can do something more elegant with walking the trees in a generic way.
Cost is only one uncrush at most before streaming can start.

Fastest to implement by a long way.

## V5 per pulse cached walks
Each pulse should store its blockset within it, if we know it.
In a background thread, using a lazy resolver, server would walk each new pulse it created and build up the list of blocks unique to it, to speed up requests for it.
This could be exactly like bake, and acts like a server side bake, storing the total in each iporm object, then totalling these up to get a summary.
These jobs can have a `.hurry()` function attached, so if the job is needed quickly, it stops yielding.

Request for a pulse first checks prior.
If no cache, builds the prior blockset of the pulse including the hamt and stores in the pulse.
Then checks pulse.
If no cache, builds the pulse blockset including the hamt and stores it.
While doing this, it streams down any new blocks that are found.
Blocksets stored as a promise so we can serialize concurrent requests.
Then, current begins the child walk by calling hamt diffing.

Diffing can be used to reuse a prior hamt blockset.

At crush time, not just diffblocks but also total block count is stored.
Diffblocks for what to store are done by walking the set and finding things not included in the prior Pulse.

Could this just be the reverse of the object cache ?  Getting the blocks just walks the tree down and tallys up the list of blocks it finds, rolling up.
Crush would update an immutable map of the blocks used in the object.
Need this else the uncrush lookup will no longer work.

When requested for deep, the child walks push the `{pulse, prior}` pair onto the walk array.
If there are cached blocksets for either, use these, or generate and cache.
Means we do not have to rewalk the whole complex each lift request.

Immutable.Set() should be used so that we can calculate the next blockset using the last one rapidly.



## Unifying walks
We seem to be always walking.  There must be some way to unify walks to make them an iporm feature.

## HAMT walking
If the walk was at the block level, then can supply a stream of blocks that are definitely different between two hamts.  There is no notion of a modified block, only an addition, so the diff is represented at a set of blocks that should be able to be rapidly walked.

Then, of those diff blocks, we can rapidly tell which ones have modified values.  Walk all the values and try get them from the prior hamt ? if different, revive the value too.