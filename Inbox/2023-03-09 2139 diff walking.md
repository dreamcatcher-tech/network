
>[!tip] Created: [2023-03-09 Thu 21:39]

>[!question] Targets: 

>[!danger] Depends: 

Often a lift needs to occur when we already have something relavant.
Lifts are always rooted in pulses, so we start by comparing there.

Make collectionList use the api and lazy loading model to update only when the crisp is known to have changed.  Present skeletons at all other times.

## V1
When walking the children of the pulse, we can try get the same channelId in the prior pulse, knowing that it is stable.  If we do not have any channel, then we know we need it.  If latest is the same, then we return.  If it is different, then it gets submitted as prior.

Takes advantage of the stability of channelIds.

## V2 use a subtracting resolver
Each pulse we find that is on the same channel but has a different pulseId, uncrush the prior using logging resolver that does not stream down, then uncrush current and only stream when a block that we did not previously have was found.

This can be done as self, hamts, then children.

## V3 intelligent walk
Use hamt compare to get the adds and mods for the nonBakeSkippable hamts.
Once have the diffs, use a logging resolver to stream down the hamt blocks while walking the hamts.
Then, walk the child list to get the pulses that were new, 

## Unifying walks
We seem to be always walking.  There must be some way to unify walks to make them an iporm feature.