
>[!tip] Created: [2023-03-09 Thu 21:39]

>[!question] Targets: 

>[!danger] Depends: 

Often a lift needs to occur when we already have something relavant.
Lifts are always rooted in pulses, so we start by comparing there.

Make collectionList use the api and lazy loading model to update only when the crisp is known to have changed.  Present skeletons at all other times.

## V1
When walking the children of the pulse, we can try get the same channelId in the prior pulse, knowing that it is stable.  If we do not have any channel, then we know we need it.  If latest is the same, then we return.  If it is different, then it gets submitted as prior.

Takes advantage of the stability of channelIds.

## V2 use a subtracting resolver
Each pulse we find that is on the same channel but has a different pulseId, uncrush the prior using logging resolver that does not stream down, then uncrush current and only stream when a block that we did not previously have was found.

This can be done as self, hamts, then children.

## V3 intelligent walk
Use hamt compare to get the adds and mods for the nonBakeSkippable hamts.
Once have the diffs, use a logging resolver to stream down the hamt blocks while walking the hamts.
Then, walk the child list to get the pulses that were new, inflate those fully using the loggingResolver.  Walk mods and use a diffing resolver

If the pulses resolver tracked what it loaded, and we could access that in the pulse, we could skip a resolve.
The summary of all pulses since it was first uncrushed should allow us to know if we ever sent a block before, so in the latest uncrush, check with the prior one if we loaded it ?
Use immutable maps and merge them each time ?
But would it need to be built from scratch during lift, as we might have dropped some blocks ?

## Unifying walks
We seem to be always walking.  There must be some way to unify walks to make them an iporm feature.