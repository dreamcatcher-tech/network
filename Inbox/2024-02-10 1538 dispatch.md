
>[!tip] Created: [2024-02-10 Sat 15:38]

>[!question] Targets: 

>[!danger] Depends: 

Dispatch occurs in the cradle.
It gets turned into an action, and put on the cradle queue.
It is opened and processed by one of the direct functions in the artifact isolate.
This in turn calls the io class.
io.dispatch contests for headlock so it can commit the dispatched action into the pool.
Once it has been written successfully, the headlock is released, and jobs to run the serial processing are put on the queue



The problem is that there is only a single queue, and it currently is held by the artifact isolate.  So we could wrap the functions into

Dispatch is really only commit, and then this triggers other functions to start operating on the committed items.

The question is, should the commit process then go and execute everything in that commit ?
- Makes things a lot simpler by removing:
	- one more type of queue in the system
	- lock contention to commit reply back in
	- taillock to execute serial processes
- has weakness that it will suffer under high serial load.

After commit, it would keep hold of headlock, and do all the execution serially.  Meanwhile, we could be missing chances to spawn new processes to tackle more load.

Could make a runlock and a headlock.
Grabbing the taillock means you are taking on the role of running the io.
As soon as a commit has occurred you can vie for this role.

Each commiter could attempt to get taillock and carry on, until their commit was removed from the execution stream.