
>[!tip] Created: [2025-09-19 Fri 13:13]

>[!question] Targets: 

>[!danger] Depends: 

if we have a gateway app that handles clerk, and then once the use has proved their clerkness, they get redirected to their computer.

they are their browser, rather than they are their computer, so they might have access to other computers based on their clerkid.

each computer is a folder on the server, named after their clerk id.
they can make other computers, but something in there points back to their clerkid.

have a gateway service that walks users thru the auth loop.  this is clustered.

Each computer has a clustered little image of fast machines that handle the incoming traffic, check auth, wake up workers, assign fibers to workers.

these are nameless and stateless.

we do several fly replay hops
1. hits the external gateway which handles auth
2. fly replay over to the computer the user is trying to hit after checking the auth
	1. look at the dns name and figure out the computer mapping
	2. create the computer if it does not exist
	3. fly-replay over to the app that represents the computer they are trying to hit
3. on the computer gateway machines, fly replay to the agent they want to hit
	1. look at the subdomain to walk the proctree to find the target agent
	2. check the auth allows them to connect with that agent, using just the nfs state
	3. if allowed, ensure there is a running machine for that agent
	4. fly replay onto that agent

principle: each computer is reponsible for its own auth.

The nfs fiber state does not have to be commited to start with, as it can be just pure nfs disk persistence.  file locks ensure that the agent is exclusive on the file.

flat fiber ids for each agent, just monotonically increasing.
tree can be deduced from the flat layout.
names of the agents are dynamic and are in the agent state.

git repos are stored flat, by a monotonically increasing id ?
or have no overlaps, since we cannot efficiently make use of the same git repo in several locations

workspaces are stored per agent, in the agent state.
agent state has the boot config, the workspace, and the running state.

