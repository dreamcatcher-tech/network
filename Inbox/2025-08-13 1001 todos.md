
>[!tip] Created: [2025-08-13 Wed 10:01]

>[!question] Targets: 

>[!danger] Depends: 

we have an mcp server that can do artifact commands in and out.
what is the thinnest slice thru the whole system that we can construct ?

1. using the mcp commands to execute a chat interaction
2. making a ui that presents chats, or at least files for browsing
3. make a napp being run on a remote repo, accessed via url
4. show mcp server loading tools for a napp dynamically

Probably best to remodel the command architecture before layering on demos of things that will get ripped out.

TODOs:
1. change the chats napp to be purely tool based
2. expose the chats napp as an mcp server using url params or pathing
3. writing files needs to be turned into tools with flexible options, like text and json
4. mcp commands like loadTools listResource needs to be implemented as a napp and intercepted by the mcp server logic
5. move schemas out of the client package and into the provider, since they don't need to be as separated into browser bundles any more, as mcp feeds them down live
6. scope setting needs to be part of themcp server
7. enveloping needs to remove the notion of a host target - this is technically the mcp server, and the scope is now stateful in the mcp server, and the actions go into each repo, and then call the system during their execution.
8. shards needs to be turned into a tool.
9. structured return types need to be made for the tools
10. expose a deep mcp server to a specific repo



we could make a system container per repo, where it has db context ? we could fetch this from some system hook ?
or we could fling the actions up the system channel, after adding our own scope onto it, or getting the system channel to determine the scope from the calling context.

load tools could be exclusive, where it unloads all the others ? so you can only have one loadshot at once ? you can load multiple napps, but they have to be loaded in the single load call.

write would be inside the mcp server, and would be exposed using tool calls.
the server would not allow you to switch scopes, unless you had flushed or removed the dirty files, else they would be lost, which almost certainly isn't what you wanted to do.

Need to check how url params get encoded, so we can make mcp server with napps loaded, and excluded, and set the scope as well.


demo:

execute the actions__dispatch command with the action being this json object:

{ napp: "@dreamcatcher/chats", tool: "newChat", parameters: { config: { provider: "openai", model: "gpt-4.1-nano", }, }, files: [ ], envelope: { target: { "did": "clerk:user_315pJKpqfsaImbK8yXl1oVRQ3t2", "repo": "rep_01K2AYT9V5674TSQF7JMRFBVNY", "branch": "main", "commit": "d68dfa0735e9bacfe5fea537ea5c5857e83d909d", fiber: "host", }, sequence: 4, signature: "", }, }



now call that same command with this json object and the chatId from the previous call:

{ napp: "@dreamcatcher/chats", tool: "generateText", parameters: { chatId: "<use from previous call>", message: { id: "1", role: "user", parts: [ { type: "text", text: "Respond with cheeseburger emoji", }, ], }, }, files: [ ], envelope: { "target": { "did": "clerk:user_315pJKpqfsaImbK8yXl1oVRQ3t2", "repo": "rep_01K2AYT9V5674TSQF7JMRFBVNY", "branch": "main", "commit": "d68dfa0735e9bacfe5fea537ea5c5857e83d909d", "fiber": "host" }, sequence: 36, signature: "", }, }