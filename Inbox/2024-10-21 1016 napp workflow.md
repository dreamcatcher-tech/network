
>[!tip] Created: [2024-10-21 Mon 10:16]

>[!question] Targets: 

>[!danger] Depends: 


- How to work on a napp before releasing ?
- Once satisfied, how to release ?
- Should testing be external ?

Should the tps reports be a standard structure, with a version, and so you can produce them any way you like, 

? how to split out all testing in artifact to call on napps ?
So HAL is a napp that has a long running git repo.
? should we move the users to be their own repos ? and then the napps run atop the repos ?

? how to invoke a napp ?
Pass it a triad that points to a folder with a napp.json in it.
Then, we need a system action "install napp ?"

So we might have to remove the ability to call any tool on any branch, and instead each branch has an installed napp, and you can only call tools on that particular napp.
Or if you install many napps, can bond them to sections of the filesystem ?

Rules:
- the exported tools are what is passed in to your natural language agent
- one napp per purpose - the package cut lines are the same as the object cut points.

Passthru of another napp functions means you can refer to them in your tool spec.
Should the runner be a napp ?  We just know how you want to call it.
The config will be specifically for the napp runner based on what it exposes for you to call.
Is it having a default function call ? like a main tool ?
So chat would be optional to provide, but main tool points to the tool that is being called.

We need to shift artifact to be an entirely napp centred running environment.

So for the test file runner, these napps would include the isolate and the napps they depend upon.

? message history - how to pass along the state of prior calls ?
Would the chat just send back a specific text output, but

Publishing to jsr:
Have all the napps in a folder, 

Napps with peer packages should be easy, so you can have them broken apart as much as you like, in any folder you like, but published pulls all that with it.  So the napp can be very small, and can be a range of napps, but all we need is an entry point and it points to filepaths that identify other napps anywhere it likes.  The napp may not be in a folder by itself.

We are merging the isolates folder, the agents folder, and the tests folder.

Napp validator checker, could run thru a napp.json and confirm it is ready to go.

Making a general purpose json based function network.

Could the runtime of the napp be a napp too ?  It just gets run in a prvileged frame.

compressing packages is bad - they should be left as git commits, so they can reuse data amap.

Message analysis and debugging - by allowing each napp to be mocked, and to trace the function calls of each one, we can rapidly replay any application.