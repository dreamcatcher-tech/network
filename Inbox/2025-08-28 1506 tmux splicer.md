
>[!tip] Created: [2025-08-28 Thu 15:06]

>[!question] Targets: 

>[!danger] Depends: 

if we just use tmux to present the shell, then we can build features on top of that.

then can proxy the request thru to the session using hono.
so we start the service on an internal port, and then use hono to auth the request, and then pass things straight thru.


if I'm in a tmux session can I hide it ?

We can have a readonly view if the person only has permission to read only.

then we can tee off to disk with each thing, too.

if they exit the program, we would just restart it immediately.

we should stop the agent modifying itself directly ? but it is in effect the users container, so who cares ?

what's the first thing you see when you enter ?
- the coordinator agent in a shell, with the stateboard showing you files.
- it has the tooling to create new agents from the library.


once you oauth, then you can see your profile data as part of your root fs.
talk to the infra agent to get your own space set up.

Why not just be a console app ?

why not the whole thing be a zellij view ?

artifact controls the permissions, the state, the reliability, but the docker containers are the executions of the app.

come in thru artifact to get your creds etc.

then, come in and see a zellij shell.

this agent can start other agents.
you can also browse your files, and your other chats.
you always have an active chat, so this might as well be it ?

this thing has some mcp tools installed that lets it fire up new agents, that are configured as you wish.

So why have a web server at all ?
Just have ssh keys, and you ssh into the system.
You have your own app, with your own url, and this is what you ssh into once you have provisioned your keys.  You always have one container up, and this is what gets attached to.

Can optionally have a web based login.  This just presents the shell interface in a browser.
Later we may embellish this with UI elements and use the cli protocol under the hood.

the ui you see is just ssh'ing into each child, to show you what the agent is doing.

Asap we need to store the messages in protocol form, and then be able to recreate them in whatever medium is requested, like tui, or react components, or text to be processed by an agent.

if its the same agent with the same files then it should be the same container, but it does make it sandboxed, so it might just look like a separate container, anyway.

maybe the zellij web server ?

It gets too silly if we have multiple sessions with different tab sizings, so best to have a single session with the agent, and a second session with the shell.

so actually, best to have a single locked terminal feed for codex, in fixed width, then have a second indepedent window for frames, which MIGHT contain another terminal session for doing ssh into the box.

the stateboard needs to be in the same context as the chat, else it can't do anything.

agent context protocol could be implemented, but then shared session and ui would become our problem.

one agent being able to control another agent is the first order of business.

tui is just the ui element - ultimately it comes down to json messages and git repos.
under the hood, and when controlled by other agents, its all json messages, and mcp protocol.

if we ran the protocol purely, and then we rebuilt the ui based on the protocol messages, which the cli must surely do, then we can have these interactive sessions, presented with gui ?

if we ran the mcp server, locally to the agent and interacted with that ?