
>[!tip] Created: [2023-03-13 Mon 12:09]

>[!question] Targets: 

>[!danger] Depends: 

Blocks should have a promise attached to them representing
Blocks should then be frozen, to prohibit further modification.

Based on the assumption in IPORM that one block belongs to one class, and all instances of that class should be the same thing.

Because the objects are shared, does this break baking, since crushing might return different versions of the object ?

If the bakes were separated from the blocks, then we have better control over them, and can manage each one independently.
Endure should update the pulse cache, but deeper, crush should replace items with their cached versions. 
We would decouple the dependency between the passed in root pulse, and the resolver.  The resolver should be free to manage its own cache and pass back duplicate items, without ruining the bake.
Always use the CIDs as cache keys, which is a very useful property of CASs.

Separate the bakecache from the pulses, so we can do our own cache management.
Cache by CID to retrieve the baked instances ?

## `.crush` 
This should return an object that has been deduplicated across the object cache, so two objects that are still in reference that are of the same block should have reference equality.

## `.uncrush` 
If there is not a cached thing in the block, it immediately sets a promise to block others from uncrushing in parallel.
Once crush is complete, it attaches itself to the block, so any future uncrush can use the object cache.

## Persisting the bake
The object cache should automatically persist bake efforts.
However, regardless of how the bake is cached between pulses, due to tearing, we should be providing the past crisp.

Rules for the crisp are:
1. If the current crisp is indeterminate, use the last crisp.
2. The last crisp, if indeterminate, has a link to its last crisp, and so on, until exhaustion.
3. 

Might store the relationship in the maps that get snapshotted.

## Blocksets
Starting with a pulse, walk and accumulate all the blocks.
Compare with a prior item.
Do not traverse historical pulselinks.

If walking children, treat as a totally new pulsewalk
First walk, then cache.

### V1
Use the isCidLink function to get a list of links.
Store in the accumulator.
If not a historicalPulseLink, refeed that object into the walker.
Hamt walk using entries with a logging resolver should be sufficient.
while walking the hamt, feed its values into the walker to be added to the accumulator.
If asked for children, walk the network and push up into the pulse level walking queue.
