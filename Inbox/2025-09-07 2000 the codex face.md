
>[!tip] Created: [2025-09-07 Sun 20:00]

>[!question] Targets: 

>[!danger] Depends: 

tool call comes in from anywhere, asking to start up the codex face.

the codex face is not really special, it is just a spawn command that has stdin and stdout tapped, so that it can be run and has a hook to call back when the thing comes back.
This would have an mcp wrapper around the outside.

actually it is special because it needs to present an mcp tool call ?

we should start with trying to make a bash face.

it has to be in mcp format, since it is being balled by an llm.
the face view can allow pure human interaction with it. 
this should be an mcp option, to deny human interactions ?

I send an instruction to the face manager, to start the codex face.
when I read this face, I get system status, but also the status of the tool itself, which can be made face aware.  most programs have some kind of status output.

the codex face starts, and I get back a port number to reach it on.
this is where the interactions will be targetted ?
So what's the interactions manager for ?

face is now running, and this is equivalent to the codex process.
using face management, you can see that it is running, and can see what views it is presenting, one of which would be the view of the codex terminal.  In this view you can interact with it directly.

interactions is a server that is always running, and so if a face starts up that is interactions capable.

faces need to indicate what they are capable of, and receiving interactions, which is to say can tool calls be sent in to them, that seems important.

interactions send to a face, regardless of what view that face is presenting.
a face can present multiple views, and of various kinds, which could be ports that have web port access, or tcp ports, pages, or api sockets.
A port would be just a face view.

interactions are independent - these are mcp initiated tool calls that go into the face, regardless of whatever faces it is presenting.
interactions are like view 0 into the face.

? does the running face need to be presented as an mcp server ?
eg: in codex, this is a running instance of a "thing" and it has some stdio behaviours, but it should probably be wrapped in an mcp server for interaction with it ?
however, that is probably what the interactions mcp does ?

some faces cannot be interacted with, so their capabilities need to be declared.

the codex exec is wrapped in an interfactions compatible wrapper.
it presents its views to be viewed in the browser or the terminal in an interactive way, but it also presents itself for interaction compatible interactions.

so the project to wrap it would be a face-* project, which matches the face interface spec.
this face interface spec allows it to be process managed by the face mcp server.

The running command is also able to be interfaced with using the interactions api.
interactions let some remote mcp server send in a tool call, check its status, and await the outcome.

the web server presents all the mcp servers as one, since they all go the same place.

? why we don't have the faces be mcp servers that dynamically pop up when called ?
because then the agents that are interacting with them would have learn some new tooling.
this is the error of requiring the calling server to know about the mcp shape of the remote, and to update what its tool calling can do.

we *should* be able to mimick the terminal tooling with these simple tools types.