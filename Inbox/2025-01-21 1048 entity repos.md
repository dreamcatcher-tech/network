
>[!tip] Created: [2025-01-21 Tue 10:48]

>[!question] Targets: 

>[!danger] Depends: 

Billing info would be stored in this repo.

It is good that each user should be a repo, since that means that hosters always operate using this portable form.

Hosters could have individual accounts with people, which then pay for the hoster to participate in consensus over a particular repo.

Means the user account is fully transportable.

So we'd just have user repos, and then everything else is a flat repo.

Or, all repos are flat, and the did points to the home repo.

This better since ownership is just altering pointers or reponsibility.

Being able to share repos between multiple dids is useful.  The reverse mapping could be stored in config of each repo.

Either way, it would appear we need some environment controls, like a store of environment config for the users, which means we need to key the repos differently to the env mappings.

Either way, need a special tool to create the entity repo, or the entity env data or something.  

`createEntity( did: string )` is required to set up a new entity
Or use use the hard coded single entity setup.


As a shortcut, we might store a mapping of did to repo public keys, which is used to check access.  If you prove the did, then you have access to whatever your did points to.


Could a user have a decentralized account, where they simply hold funds in crypto with us, and their ID is their wallet ? in which case they don't have a home repo, they just pay for some other repos to operate ?

You always need some kind of dashboard with us, and that is what your home repo would be.

readEnvData could be fulfilled any way we like - dedicated database values, and a dedicated repo.

have super DID which is some key set in the env vars of the server, which is all powerful.

When clients connect, they join and either know the repo name they want, or they grab the first repo that is listed.

We should bind the name of the default to something.