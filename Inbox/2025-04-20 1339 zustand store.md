
>[!tip] Created: [2025-04-20 Sun 13:39]

>[!question] Targets: 

>[!danger] Depends: 

```ts
const dir:Meta[] | undefined = useDir('some/path')
```

should be able to watch something using the hook, rather than having to call a function directly ?
This should start up a watcher ?  and auto tear it down when the hook unmounts ?


currently we can just use watch and unwatch in an effect.

purpose of useStore is so it can trigger rerenders on change.

persist the store to save it from loading every time - when we rehydrate, mark everthing as stale.

share it between tabs with https://github.com/react18-tools/zustand-sync-tabs

but they say that the store IS a hook already, natively ?

ls on a full path - all of them should be stored in a map, so we never ask the same thing more than once.

sharded watches need to avoid collisions

make a store of the last five minutes ago, so we can highlight whats new.
store the config of the watcher as state, and then trigger in response to it ?

There's an issue that during the synchronizing the old tree is being wiped out and we're not taking advantage of the fact that the OIDs may be the same and we can skip the sync. 

So we could make the Watchers be aware of the previous state and so when they detect a change in the Route OID they would then start reconciling with this existing version that they have. 
It's like there's a second layer, which is the promises that resolve each meta object, and then walk the dirs.

We have to allow a file to be fetched, and sort of watched, but without being super heavy, like making a whole new store watcher, so that a virtualized table can fetch files rapidly and ephemerally, then as soon as the row is not needed, the watcher stops.

Being able to see what has changed in the app since any previous time should be easy to do. We simply walk back the commits to a time that is within the user-specified range and then we walk the trees to find the diff highlighting adds, deletes, and updates in traffic light colors. We should be able to do this across the whole app for any particular field.

These React components should be able to take this standardized color annotation somehow. 

If a component is trying to render and there is a new version coming, then it should use the previous version of the store if it even had it while it waits for the new version to arrive. But it needs to flag somehow that it is stale. 

So there's sort of like, this set of promises that is collectively drilling down thru the filesystem tree, driven on by each specific watcher that is trying to get to the path that it is given to watch.

The artifact functions based on files read because they are bound to a commit can never change and so each of these calls that is made in the client should be intelligently cached in some way ideally using weak references so that whenever the artifact thing that contains them is removed they will be removed shortly thereafter. In this way, any callers (such as the synchronizing watches) that may call the same function many times don't have to worry about any of the caching or optimization of these calls.

Another option is that each watcher has its own tree. The caching would then be in the artifact calls to look up directory listings for a specific commit and other such things. Each watcher would just get its own slice on the store. They would all do the same mechanics when a new root oid was set, and would go off and walk the directory structure.  They would look at their previous syncs and re-use anything that was the same, or we just keep a large cache of all the tree objects, by oid, and we pull these in as needed.

This means that sharded watchers are immune from collision with regular watchers.