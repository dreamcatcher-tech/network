
>[!tip] Created: [2025-04-20 Sun 13:39]

>[!question] Targets: 

>[!danger] Depends: 

```ts
const dir:Meta[] | undefined = useDir('some/path')
```

should be able to watch something using the hook, rather than having to call a function directly ?
This should start up a watcher ?  and auto tear it down when the hook unmounts ?


currently we can just use watch and unwatch in an effect.

purpose of useStore is so it can trigger rerenders on change.

persist the store to save it from loading every time - when we rehydrate, mark everthing as stale.

share it between tabs with https://github.com/react18-tools/zustand-sync-tabs

but they say that the store IS a hook already, natively ?

ls on a full path - all of them should be stored in a map, so we never ask the same thing more than once.

sharded watches need to avoid collisions

make a store of the last five minutes ago, so we can highlight whats new.
store the config of the watcher as state, and then trigger in response to it ?

There's an issue that during the synchronizing the old tree is being wiped out and we're not taking advantage of the fact that the OIDs may be the same and we can skip the sync. 

So we could make the Watchers be aware of the previous state and so when they detect a change in the Route OID they would then start reconciling with this existing version that they have. 
It's like there's a second layer, which is the promises that resolve each meta object, and then walk the dirs.

We have to allow a file to be fetched, and sort of watched, but without being super heavy, like making a whole new store watcher, so that a virtualized table can fetch files rapidly and ephemerally, then as soon as the row is not needed, the watcher stops.

Being able to see what has changed in the app since any previous time should be easy to do. We simply walk back the commits to a time that is within the user-specified range and then we walk the trees to find the diff highlighting adds, deletes, and updates in traffic light colors. We should be able to do this across the whole app for any particular field.

These React components should be able to take this standardized color annotation somehow. 

If a component is trying to render and there is a new version coming, then it should use the previous version of the store if it even had it while it waits for the new version to arrive. But it needs to flag somehow that it is stale. 

So there's sort of like, this set of promises that is collectively drilling down thru the filesystem tree, driven on by each specific watcher that is trying to get to the path that it is given to watch.