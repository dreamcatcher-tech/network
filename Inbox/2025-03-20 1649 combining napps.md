
>[!tip] Created: [2025-03-20 Thu 16:49]

>[!question] Targets: 

>[!danger] Depends: 

Whilst you could select from multiple registries for the same language, any given napp can only use a particular runtime.

So if you want to make multiple languages work together, then you'd make a napp for each one you wanted to bring in, then you'd make a higher napp to combine them together.

The dreamcatcher napps registry should be browseable too.

Docker registries should be available also.

You should be able to connect your own, and you should be able to connect a github repo, or some other private repo.

So you could manage your repo sources, and this is where we would build out your napps from, some of which might be personal / private.

The compute overhead of this could be quite low, since they would all be running largely on the same container, so they call somewhat internally.

When we bill customers, they could select if they want a shared container, dedicated container, or dedicated per repo (so dedicated per their customer)

The type of security offerings would be precautionary, where we explain how we have layers, and we take precautions of different types and the costs associated with them.

Then would you pick where to deploy to ?  our hosting service, yours, a hybrid, some others ?

We should also have over the maps a way to run them in a test environment. You should be able to chat with them within the registry and also be presented with a JSON schema form type of interface so you can see the different types and play around with them. Push them in, put in, see what happens. See past results, past history. Basically you would be presented with the same agent desk or agent portal that any other agent would have and you can see their historical messages and roll back to them replay them reorder them all those kinds of things.

you should be able to search across all repos at once using an AI-powered search to help you. 

It might be easiest if we just import all the registries anyway rather than relying on querying them separately. 

Git providers would be dreamcatcher, github, gitlab, plus add your own one, which will create a stuck that you can watch.

Services in the gateway can be connections to github issues, confluence and jira.
Connect to heroku, so we can manage external platforms using our napps.
Even manage subscription and account preferences in things like adobe suite of products - if we can't get api access, then use operator browser driven methods.

eslint as a napp or a tool in a napp would be super useful, since can get the bot to loop on linting issues.

We could provide things like a fortran container - this can make it easy to set up rather exquisite dev environments for all kinds of code.  Then to get AI assistance, and if you want it, human assistance, all while keeping the code secure, since you can just share snippets or parables that the bot knows how to apply for you, all under the watch of the semantic firewall.

SO THEN the napps registry lets you publish packages for languages that don't have a central registry, and for those that do not support the package format, since it can be made just a folder or some other kind of folder related standard.  Plus you can run them, compile them, check them, deploy them, all right from the web browser.

Why should I be limited to just the code in one language, when there is all this great stuff out there ?

Also, maybe the best ones should be wasm'd or something ?

Make a registry that uses AI operators to go and search all the other registries, using the web interface, so that when it comes back, it has the best recommendations for what you were after from all the registries, and has made a napp with some example uses.

Where else has this multiple source of truth problem where you have to search several things concurrently ?

Then can make notebooks that can draw on napps to run, to enable further experimentation.

To provide Meta Registry search capability, how can we leverage the Mango Query language to model this? 

For example, we could make a de facto package format for MS-DOS programs, where each program is distributed like a regular DOS program is and the Docker container just serves to exist solely to run that one application. It would then provide the terminal stream in and out. This could be block chained. We can also have it snapshotted periodically in and out so we can replay it. You might even be able to run Doom or some other kind of game like that. We'd need some way to not be doing one block per keystroke for example but be more continuous and streaming mode where we periodically snap the state of the system somehow if that's even possible. Probably going to be running as a side effect with a real-time connection hooked up over the top 

we could become a de facto package format for WASM, even. 

run a chrome napp, which would use headless chrome to do something, which might include doing some browsing or some orchestration.
## Connecting a napp to ethereum or other blockchains
The napp running on its own is nothing in these systems.
Running a napp using the API of the contract makes it act like a weird mix of service as well as remove napp ?
The runtime would be `ethereum` and some chain id, but other than that, it would operate exactly like a napp, otherwise.  On artifact, the changed system state would be recorded as blocks plus the data storage of the contract that changed.