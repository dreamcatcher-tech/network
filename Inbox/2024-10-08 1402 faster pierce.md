
>[!tip] Created: [2024-10-08 Tue 14:02]

>[!question] Targets: 

>[!danger] Depends: 

Currently the pierce system requires the isolate do many round trips with the db, which might be far away.

Instead if we simply wrote the pierce object to the queue, and then laid watch to a key that got updated once the pierce was ingested, the overall process might be significantly faster.

We could use this same method to update replies to a piece when they are done, which means we can purge the `io.json` instantly, and then just write the object that was the reply to the db, with a timeout of like 15 minutes.

We might then be able to remove the difference between a pierce action inside the io.json and so we only have one kind of Request object.

A piece would just simply have no further transmission required, as the origin would the external world, and something else will handle that.

Browser can store its pierce ids locally, and resume them on refresh.  Or not really care, since we don't actually make any use of the result of the pierce anyway.

This same action would be used to cancel and to bill against.

Pierce might then be just part of pooling again, since we don't care about it being separate and faster any more, since it can be just another action in the pool.

We could run the pooling of pierce separately, since the perf gains of merging seem small but the programmatic complexity is large.

Pooling pierce might enable faster load times in fixture tests too, since concurrent requests would all get pooled together, and executed in a batch.

We should allow for multiple actions to be executed in order, before doing a commit ?

We can accumulate the transmissions and do them all at once.

Transmissions to another branch can only happen when a commit occurs, but before that, we can keep looping a lot.

When the pierce has been replied to, we write the commit where it applied to disk, then the watcher, if it needs it, can fetch directly by commit.

But the issue is the size of the pierce, in case it is large.
Write pierce as a blob, and then enqueue a references to it.
Delete this when it gets processed, then at the same time, write the reply that points to the commit that contains the reply.
This is part of the transmission cycle of the system.

