
>[!tip] Created: [2025-01-21 Tue 10:20]

>[!question] Targets: 

>[!danger] Depends: 

We could make a code writing strategy that allowed the LLM to flop and then post-processed it to meet our requirements. The flop could be flared so that it is running multiple versions with the best being selected, as well as a strategy or architectural analysis where we use that to generate a top-level architecture that we then apply. But the point is that once the code is generated without any encumbrance, then it gets rules applied to it, like don't use the any type in TypeScript. Don't use steps and test functions unless they build upon each other. Formatting rules, linting rules, where some of these can actually be code tools that run iteration on lint errors. And so we set up these mini pipelines which can be composed on the fly as well as being static depending on the use case at hand.

To copy a UI, copy the dom elements, and provide a screenshot, and work with the bot to polish the result.  This gives very powerful copying results.

Then break the UI up into storybook components, and work on each one in isolation, which can be done well in bolt.new, since we can lock and target files.