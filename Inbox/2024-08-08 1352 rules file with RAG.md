
>[!tip] Created: [2024-08-08 Thu 13:52]

>[!question] Targets: 

>[!danger] Depends: 

If we made functions that used a stack based tool to push and pop arbitrary items from a stack, then we can have large numbers of things.

So keeping rules about how to assess test files for good style, we could push them into this long object.

The items need not be structured in any way, unless we specifically wrote a schema to it, in which case it would reject when we push.

Allow reordering these items.

A widget can be made to allow sorting of the items.

Widget can be coded to take a lookup parameter, where each item has a lookup key on it, which then goes and looks for files at a certain location which match the name of the item in the stack.
Can be used generally for customer ordering, or business rules ordering.

Then on display, the relevant fields can be extracted by a live AI call that is presentation only, just like how transcribe is.

For example, have a rule for test files that participant names shouldn't be close together as they might get mispelled.
Check for misspelled participants that might mean the same thing too.

These rules can be ragified, so the object can have vector lookups in it too.
The prose, or purpose of the text can be stored in the summary, so that a query can be generated that would best suit the style of the text that is stored here.  If it is a list of answers, then you need to generate an answer to get the best results out.

These files and the assosciated tools can be used to make indexes that are searchable by isolates.

These files could be generated all over the place to provide ways of thinking about directories of files, and files themselves could be broken down in this way.

The files could include mappings, where the original data is a chunk, and the mapping transforms it into something different.

Upgrade tranforms could process these files when a new requirement is given, and we could walk the list with transformers in parallel.  Provide a widget that shows the transformation status of these data structures.