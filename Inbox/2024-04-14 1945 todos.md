
>[!tip] Created: [2024-04-14 Sun 19:45]

>[!question] Targets: 

>[!danger] Depends: 

openMachineSession should handle duplicates gracefully - guts-session test
session resume should check if the pid is valid and throw if not - or create the session if not
make a provisioning function that allows arbitrary provisioning to occur depending on the system
why is hot ping causing branches to form ?
speed up the system in test environment
	Native pierce relay, rather than thru an isolate
	lazy branching without doing a commit
	Branches should be more instantaneous 
	For daemons, no need to send a reply back
	pierce relay should be native
	pierce tracking should be not splice based
	Do not use the queue if you can do the next action directly
	branches should be skipped in creation if they are transient
Machine cannot use deno env vars, plus needs to be browser session storage compatible
recover existing machine session and use a liveness test
make work in browser
stabilize the whole system, republish, then do machine merging
implement at rest encryption
machine merging
speed up cloud usage
use sessions properly in the ui
Native relaying when do pierce
Pierce should be atomic and retry
multithreaded ai chat in test environment
github login
show threads of help invocations in UI
backstage admin view for graphs of the whole system - show historical token rate
navigating git in the UI
be able to update HAL and push back to the core repo
small customer test
larger than atomics can handle features - be able to spawn 1000 branches gracefully
large customer test
mertrics on cloud, including error rates, so can tune effectively
certain errors in atomics should be atomic errors and not cause a message retry
atomics should be resumable very cheaply, with all async ops done at once, before commit
store pierce outputs directly, so that splice watching can be skipped over
reliable high volume transaction processing, but start with reliable low volume for SM
Benchmarks
Do not clone HAL each session, do this only once on account creation
Change account management in the UI to use dedicated account chains
batch branching

Full user account testing
oauth
billing
Large file loading
Parallel intelligence tests

Modifying lots of files in parallel, like separate customer records.
Dashboard with total processing for the platform, and the protocol in general, like tokens consumed, ai credits spent, db writes and reads, data under management.

inside a deploy instance, is each run isolated fromt he other ?
how much impact does the ajv schema step have for us ?

isolate reuse counter by storing a global and incrementing it each time.

How can we get back to helps and generating NL apps ?

Fine tuning on synthetic data once we have big prompts that we like and want to bake the model down for speed - can bake multistep operations to increase speed.
Vector db usage so we can use embeddings liberally, to make recall across large datasets.