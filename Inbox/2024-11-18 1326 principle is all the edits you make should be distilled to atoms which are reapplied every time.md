
>[!tip] Created: [2024-11-18 Mon 13:26]

>[!question] Targets: 

>[!danger] Depends: 

The theory is that the thing you want is internally consistent, because the universe is, and so if you are working towards something, every time you make a correction, we should take note of that, and be building up a base set of facts.

Difference is declarative vs imperative ai programming.
Declarative reasoning takes all your imperative corrections and turns them into the declarations that you would have said.  It then checks with you that these are correct.

This then is our entry into the coding workbench forum.

So in the background, it would look at the edits you were making, but since it was the source of the code, it would look at the code, plus the edits, and see if it needs to update the base asumptions.

"source" as the name, since it takes base facts and generates the code itself, rather than you writing the code and then it patching it.

Basically keeps a spec in sync behind your code at all times.

This is easily cloned by anybody, but it is applicable to all kinds of endeavour.  The social network of helping each other out, coupled with the napp registry, and the dreamcatcher rules attracting and holding everyone together, with the final hurdle being the dreamcatcher out competing all single point efforts, since it can quickly absorb, monetize, have feature equivalence, and incent disparate people to come together sooner, with less overhead, to share more prize.

The point solution company requires a much higher threshold since people need to come together earlier and with greater cohesion before they activate.

So when you are modifying a render, the top level atoms may get updated and be drawn to your attention, which would cause a shadow copy to do a range of edits thruout the codebase, which you should be aware of too.

you may snip the knowledge tree and scope the atoms you want at a certain layer.

It should be aware of the outputs of tests.

When generating code, should start with generating ts interfaces and types first, based on how the diagrams explain the interactions of the system.

Every chat you have should be part of this process, so whenever you converse, 

The key is to do this in a group - so if we are all having all our chats contribute to the atoms, and the bots can check in what we meant, and then we have group consensus ability, then we are a team.  And we are as efficient as possible.

Get correction at the time if you are talking and saying something contradictory.

Get the team to face difference circumstances, like expos chat groups interviews, and record the answers.  Drill team members on the answers.

bug bounty so when errors are detected in the core knowledge, rewards are paid out.  This is on top of the attribution.