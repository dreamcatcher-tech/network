
>[!tip] Created: [2025-05-07 Wed 10:36]

>[!question] Targets: 

>[!danger] Depends: 

The main app window should treat the stateboard like a browser and record all the navigation actions that occured.  This means the agent can drive, or you can drive too. Our widgets are just those that are aware they are being driven, but any page can be put on this anvil.

when you first arrive at an org page, they can let you chat with their agent, where they pay your tokens, or you can sign in and come in with your own agent.

The chat can have filter tools and settings.

Key is if we can have these options be reasoned about by the bot, then we can use logic and feedback to guide how the ui should be.  Each choice can then be justified logically.

Operator agents can review the ui under different metrics, like difficulty to do any particular action, generating head maps, and measuring distance travelled to do different things.

Every item in the chat history should have the ability to pick a different version of what it was and to roll back to that point. If you take an action that would change the history of the chat at some given point, you've now created a fork. This is displayed in the chat view box as a series of branches or a tree that looks like a file explorer view. It shows you places where the chat has diverged, and when you click on them, you can bring each one up in the chat viewer. 

Although changing the chat history that led you to the widget that allowed you to recall these past histories might be quite jarring because you could easily get lost, and then how would you bring back your previous chat that you were on? It's almost like a different kind of viewer needs to be shown and in something like a restore button. 

In the chat list, if you switch between different widgets, it shouldn't make any kind of difference. Like it should only change or update the latest view in the chat. There's no point showing just what you looked at until you actually took some action. When you take an action that would show up as a nested item to indicate some type of right that occurred to the data set. 

Each widget in the chat history should also be able to indicate that it represents a snapshot or not the latest thing. So when you click on it, you should see that it represents a snapshot and you should see the results at that snapshot. The title bar that is common to all widgets should indicate that you are not at the latest, give you the ability to diff with latest or some other thing, and give you other historical controls. 

I think what we're saying is that all your chats are always part of your home repo. But I'm just not sure if chats should be part of other repos, it's just the point of a chat is that it goes all across all the repos, just like you do, just like a person does. 

When searching for something, we should do first a mechanical search, but then additionally an expanded natural language search so that you could type in any kind of query and then results would come back with some reasoning why the result was chosen and they should be ranked.

The widget that shows the search result needs to show what came back, how to view it directly, and also the reasoning involved as to why this item has come back from your natural language query. 

And now for the tricky bit... 

Widgets, like File, Repo, Settings, need to now be able to be applied to a given Repo so that I can manage it just like I manage my Home Repo. How should this be done? The idea is that for any given repo, if I select that repo, I should be able to create child repos. The home repo in this case is the currently selected one. And the children can be either created, cloned, or linked, or deleted or unlinked. I'm just not sure how to make that all tie together nicely because I want the concept of having your home repo and then you can use these tools to interact with it not to be confused with when you're working on some other repo that you have access to.

we need the concept of sudo, where you can act as another user.

have a root repo, where you can change any repo to be root, so the position is always relative to that repo, and the chats are relative to that one ?

We have this concept of the working location.  There is a working root / home repo, which is a repo with no parent.  When you select

? When a repo is focused, is it always appearing flat, as in there is not need to navigate up to parent ? maybe only in the repo view is this parent tree visible ?  You can also show the full tree, back to your currently logged in actor.

You can only be logged in as one user at a time, but you can have control of multiple other actor accounts.

Repos should be promotable to org, or you should be able to make a new org repo.

There is your home repo, from which you browse everything.
Then there is the current location, which is a repo that your home has access to, that you are acting as your home / actor repo, 

Select multiple multi repos to add them to context in a chat
Exclude some items from the list.

Also show the inherited napps, permissions, and other settings from the parent.

derive a new chat from some old ones that are summarized and linked to, so the bot knows some shortcut context, but if needed can walk the prior chats to get precise information out.
chats should auto segment, so they can be exploded out.

synthetic files that are context, with a widget that helps handle the bundle.

possible solutions, synthetic, repros, deduplication.

auto problem generation

select old context bundles.

context widget needs off and on for parts - exclude and include.

cron for agents.
triggers.
agent mute and who it can talk to and receive from.

napps are apps, services are running isntances, and a running service with an inference function is an agent.
transient agent is just a chat.

navigation messages / context messages have a button to open up the context editor, which is probably unable to be added to context itself, unless pointing at a past one.

shadownames / pen names.

'as agent' or as service for a napp.

connect repo should become 'join'

chat with - start a napp and run it as its own chat window, then you can go to home chat and ask something to be done to it, whilst viewing it on the stateboard.

chats should show their location, as in repo/branch/file
they should have a settings button where they can be configured.
config is just showing which napp is used to chat to them.

presenting a repo as a napp - give it the same interface as a napp.
a complete external web page could be a napp too. and could still have access to the artifact api.

the model should be that you are the agent, so that is why your chats are only ever stored in one place ?

pull requests and the handling of large numbers of these.
auto merge agents when they decide a PR is suitable.

inbox for messaging and notifications.

email app showing how to recieve email

context is a wrapper around the selected widget.  x on it clears all, x on each item clears it.
shows version numbers for the chat. lets you navigate history and shows diffs.
context widget has tools to auto find context for you.

bug report sanitizer tries to reduce the info required to repro, but also scrubs out anything personal.

each napp should have a dropdown with the actions available to be called

napp agent format should allow for messages in a standard format that are presented like an email inbox.  Plus each message has context around it, including the execution environment that caused the sender.

multithreaded ai with reflection aware / self awareness - the ability to observe itself in its thinking processes.  dtrace for the whole system.  observability of the agents own actions and full surroundings.

sharing a context snapshot - we should be able to make these be a thing unto themselves, almost like what a stuck points to, and then treat it like a first class object.

You should be able to click on the context that was used in a previous place in the chat and reuse it in the current chat. You may choose to or you should be told that some parts are out of date and you can use a latest version, the same as pass by reference if you just there's a later version of a file but you want to use that instead. Or you could even pass the previous context snapshot as context itself. So you should be able to pass chat messages and tool outputs as pieces of context as well, plus be able to prune or transform the context in some way. 

Could an MCP server-like interface be used to allow naps to offer UI components? 

For example, a collection of components such as that used in a CRM might present a single webpage where they would render any one of those components and be connected via either an MCP interface or the Artifact interface so that they can be rendered as a frame and interact with the broader application using these message passing techniques. This means that we can publish these apps independently. The dev repo for these apps is really just a form of storybooking where we provide tests and interactions and confirm that it all works correctly. Then the app logic and UI is rendered in an isolated frame where the private context data is passed in and out by the controlling application. So everything's happening in the server-side only. 

The key here is that everything that is private to the customer is decoupled from the application logic, whereas typically the frontend and the access to the database and storage would only be very tightly bundled or connected. Here we can publish ways of processing interacting with data as well as server-side processing components, so not just browser-side UI-side but server-side heavy-lifting components and even those that use services. It's treated like an application that it runs on your computer, so it's isolated and controlled by the parent environment. 