
>[!tip] Created: [2024-01-31 Wed 11:00]

>[!question] Targets: 

>[!danger] Depends: 

They don't need to actually blank the io files, or the session files, as they can be pure patches ?

So the session chat, if sending patches down, would just walk the logs, and flicker between the two files.
These could be assembled in parallel, for speed.

If the file is designed correctly, then it still carries meaning if you don't have a base.

The io system should be using these diffs anyway, under the hood, using json patch, rather than the hand crusted version we made.

Means that trimming the io files can be done any time in the future, we just work with patches all the way thru.

Display of multiple splices can be represented as a single splice, so we can perform reducing operations on them quickly.

Viewing the block explorer should be just using the same git repo interogation tools as any other system.  Watching for commits is the same as watching for a change in a file.

Watching for commits is watching the `/` path.

Visualizer should be able to take any path, and some commit like query, and a pid.
It should then start to stream down jsonpatches of splices.
If a commit range was given, then the splices come down one for each commit, using a patch based on differences, with the first one having the full file.

Tracking a file would only give splices when a commit occured that changed it.
Once we get to the tip, we start receiving a different type of splice, which is 

Splices only deal with text based files.
Can be in object format, which is processed server side.

We can switch between json and text diffing tooling, since json cannot do text.
A text file could be split by whitespace and diffed like that ?

Key is that subscriptions are active - the api will behave differently if there are watchers for the changes.
## chat session with forks
single thread we would just subscribe to the session pid, and the session file path.

## Grabbing all the history of the channel
Each patch would come with with reference to a patch that came before it.
patch would appear as string diffs for a json object to be applied.
So client holds a string, and keeps patching it, then parsing it each time.
Store the inflated version along with the patch, so we can walk the inflated version client side.

To view the channel at a particular commit, we would walk up and down this cache

When receive patches that are past the head, these are transient, and we will always receive a full commit patch upon commit.  Transients are using broadcast channels so they might miss some data, or have some errors.
Server side the received patch is checked for errors and if it errors, we assume the bchannel was faulty, so we 