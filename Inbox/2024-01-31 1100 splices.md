
>[!tip] Created: [2024-01-31 Wed 11:00]

>[!question] Targets: 

>[!danger] Depends: 

Splices must be allowed to skip some, if the updates occur rapidly - the patch would
Include an option to notskip - gives us access to every single change.

? is getting the splices for some piece of git history the same as getting a splice at all ?
If a commit range was asked for, then give every commit ?
Or, give every commit all the time anyway ?
Polling a snapshot to get just the end result or latest seems different that getting the individual bits.

So the session chat, if sending patches down, would just walk the logs, and flicker between the two files.
These could be assembled in parallel, for speed.

If the file is designed correctly, then it still carries meaning if you don't have a base.

The io system should be using these diffs anyway, under the hood, using json patch, rather than the hand crusted version we made.

Means that trimming the io files can be done any time in the future, we just work with patches all the way thru.

Display of multiple splices can be represented as a single splice, so we can perform reducing operations on them quickly.

Viewing the block explorer should be just using the same git repo interogation tools as any other system.  Watching for commits is the same as watching for a change in a file.

Watching for commits is watching the `/` path.

Visualizer should be able to take any path, and some commit like query, and a pid.
It should then start to stream down jsonpatches of splices.
If a commit range was given, then the splices come down one for each commit, using a patch based on differences, with the first one having the full file.

Tracking a file would only give splices when a commit occured that changed it.
Once we get to the tip, we start receiving a different type of splice, which is transient.

Splices only deal with text based files.
json requires client side interpretation.

Key is that subscriptions are active - the api will behave differently if there are watchers for the changes.

Broadcast channels for changes.
Make a single channel for the changes to a particular file or path ?
Channel that broadcasts all changes for a given PID, as patches.
If there is no commit watchers registered, then there is no need for transience ?
Watch for the addition of any new watchers and if some appear, start the diffing process on transient stuff ?
Or just broadcast transient splices anyway, and do some tuning later.

Commit patches are

Pool patches ?
When tracing a given action, could get some lifecycle updates on it ?
received by edge, entered the pool, in a commit, replied to.
? How can we trace actions across many different pids ?
Server side trace the io file, then interpret it ?
Client would be streamed down splices that follow the flow of execution, to avoid the client having to rerequest these things themselves.

This subsystem should include diffing between version and between chains very easily.
The patch can be interpreted differently to show what changed between two versions.
This visualization is edgeside - not queueside.

Then move pierce watching to use this commit watching piece.

May stream down pieces of large files using diffs, to give a smooth render experience for large files.

Arbitrary spans for splices - being able to ask for a range of commits and getting back a single patch.  With no start given, the patch just gets the latest commit, if any.
But wbout if we want one patch for each commit ? 
Or a single patch that gets us from one given commit that we have, to another commit we don't have ?

The commiter should update all the splice watchers, since it already has the files loaded.
If there are too many watchers, it can send the task off in a queue ?
Watchers should have to fish out the repo and see what they wanted.
They should walk the trees with caution, so they bail when they know there was no change to their file.

? Spanning branches ? spanning commits ?

? Tree of files if we want to get the whole file structure, or just what changed in it ?

Without any span params, you get the last known commit followed by transients that reference this commit as parent.
If this is the first commit with no root, you get transients that reference nothing.

Restarting transients gives the full latest followed by anything else.

Access to splicers within isolates ?
Be able to retrieve splices for our own PID, as well as others.  Pause an isolate until a new commit occurs on some other PID ?
Be able to configure just the latest as a sloppy type of subscription ?
Subscribe to the internal changes of a json object within the repo, so the client doesn't receive much info.
Commits are strong, so a subscription should be aware of every single change.
## Splice watching for an action with lifecycles
Start by watching the io file.
Watch the pool too, so when something is pooled.
Seems more work than needed, since pooling is so brief.
? should splices be able to target a path within the json object to watch, or should this be post processing ?

## chat session with forks
single thread we would just subscribe to the session pid, and the session file path.

## Tracing consequences
listen to the commits, and watch the io.json file specifically.
Derive the new PID name from the changes to this file.
Start watching those for splices.
Use the snapshot method to retrieve only the latest known, or null of nothing present.
Repeat until have the process tree defined.

## Walking the filesystem tree
Watch splices for a given directory.
Receive splices when the js object representing this directory changes.
Probably should use the direct git format of a tree ?
Offer a recursive flag to get all children as well
Indicate if a file or directory is dirty
copy object formats from isogit
? any use to subscribe to any changed paths ?
This would give a stream of changes.
Be like subscribing to `*` as the path, or some other glob, which would emit the full path within the repo as well as the change info.
Light would just allow knowing when the thing changed, but not the contents within it.

## Watch the full filesystem and light up changes
Be able to show in React the base filesystem, show which parts are different in other processes, across all processes, show a process count for each change that is occuring, then let you flick thru the different versions of that filesystem that each process is working with.  At the very least, flick red those paths that are being altered by some processes.

Could make a universal react component that can render these complex trees and manage subscriptions.

## Get a splice at a specific commit
Use this to browse parts of a commit that are not in the same PID, when a merge result has returned.

## Grabbing all the history of the channel
Each patch would come with with reference to a patch that came before it.
patch would appear as string diffs for a json object to be applied.
So client holds a string, and keeps patching it, then parsing it each time.
Store the inflated version along with the patch, so we can walk the inflated version client side.

To view the channel at a particular commit, we would walk up and down this cache

When receive patches that are past the head, these are transient, and we will always receive a full commit patch upon commit.  Transients are using broadcast channels so they might miss some data, or have some errors.
Commit patches are based on the kv store, so they are reliable.
Server side the received patch is checked for errors and if it errors, we assume the bchannel was faulty, so we 
Server side the received patch is checked for errors and if it errors, we assume the bchannel was faulty, so we could ask for a retransmit or something ?
Ask directly for a catchup on the transient patches, so you get a catch up from the last commit before the next transient goes out.
