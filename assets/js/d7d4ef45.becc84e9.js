"use strict";(self.webpackChunk_dreamcatcher_tech_dreamcatcher_website=self.webpackChunk_dreamcatcher_tech_dreamcatcher_website||[]).push([[6830],{5358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=n(7462),a=(n(7294),n(3905));n(1839);const r={},i="R14 Debugging Dreamcatchers",s={unversionedId:"Requests/R14",id:"Requests/R14",title:"R14 Debugging Dreamcatchers",description:"There are two types of debugging tooling we require",source:"@site/dust/Requests/R14.md",sourceDirName:"Requests",slug:"/Requests/R14",permalink:"/dust/Requests/R14",draft:!1,editUrl:"https://github.com/dreamcatcher-tech/dreamcatcher-tech.github.io/edit/master/website/dust/Requests/R14.md",tags:[],version:"current",frontMatter:{},sidebar:"dust",previous:{title:"R13 Measuring DX",permalink:"/dust/Requests/R13"},next:{title:"R15 Immutable Permissioning",permalink:"/dust/Requests/R15"}},h={},l=[],c={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"r14-debugging-dreamcatchers"},"R14 Debugging Dreamcatchers"),(0,a.kt)("p",null,"There are two types of debugging tooling we require"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"debugging Interblock chain complexes"),(0,a.kt)("li",{parentName:"ol"},"debugging attribution and governance operations on Dreamcatcher objects")),(0,a.kt)("p",null,"We want to be able to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Replay any situation"),(0,a.kt)("li",{parentName:"ol"},"Remove the need for logging, since we can replay the app"),(0,a.kt)("li",{parentName:"ol"},"Make reproducible bug reporting trivial, as we can include chains with each report"),(0,a.kt)("li",{parentName:"ol"},"Roll back, fix a bug, roll forward with a patched state, and with patched software, and replay any actions that were received since then ?"),(0,a.kt)("li",{parentName:"ol"},"Be able to debug the engine itself using these very same tools, by making the engine itself run inside a blockchain")),(0,a.kt)("p",null,"mcnasty \u2014 02/28/2022\n@rexmondo how mad would you be as a dev if I removed being able to receive replies in a reducer any other way but awaiting the promise returned from making the request ?\nrexmondo \u2014 02/28/2022\nI think non blocking async await calls happen to me like 1/50 times or so\nThe clearest example I can think of is writing to a log, I don\u2019t want to cede control flow to do that\nmcnasty \u2014 02/28/2022\noh you are welcome to fire and forget\nrexmondo \u2014 02/28/2022\nMaybe I don\u2019t grok then\nmcnasty \u2014 02/28/2022\nI want to not dispatch any @@REPLY actions to the reducer ever\nif you did not await the call, then you imply to me that you don't give AF about its response\nrexmondo \u2014 02/28/2022\nI\u2019m assuming replies are mapped into the expected action for the continuation?\nmcnasty \u2014 02/28/2022\nbut if you do await the call, then I will return the continuation action payload to you, or I will throw if it is rejected by the remote chain\nrexmondo \u2014 02/28/2022\nYeah, that\u2019s very sane\nmcnasty \u2014 02/28/2022\nok good\nrexmondo \u2014 02/28/2022\nThat\u2019s how we built it before too\nmcnasty \u2014 02/28/2022\nHOWEVER if you fire and forget, and the remote side rejects, I will crash your reducer\nrexmondo \u2014 02/28/2022\nYou get the continuation action and the call environment\nrexmondo \u2014 02/28/2022\nThis is an error bubbling problem\nmcnasty \u2014 02/28/2022\ni figure thats how node does it ? unhandled promise rejection ?\nrexmondo \u2014 02/28/2022\nThis is how real promises work\nIf the remote can reject you have to provide a continuation context to catch errors\nI think that\u2019s really sane too\nmcnasty \u2014 02/28/2022\nfrom the programmers point of view in the reducer, these are real promises\nrexmondo \u2014 02/28/2022\nYa, it sounds like you got the model right\nmcnasty \u2014 02/28/2022\nthe gotcha is that I\"m rerunning the devs code each time new replies come in\nand if they don't give me the exact same requests in the exact same order, I burn them\nbecause I can't really help someone who makes their code run differently\nthey may have missed the point of blockchain\nmcnasty \u2014 02/28/2022\nOk I'll roll with that\nrexmondo \u2014 02/28/2022\nLol\nYeah, what you\u2019re saying is also why it\u2019s a bad idea to expose the runtime mechanics too much, especially when it comes to continuation handling\nThe lower level you show them, the more likely they will hand you something unstructured\nmcnasty \u2014 02/28/2022\nyeah 100%\nrexmondo \u2014 02/28/2022\nAnd then in 40 years you will have windows\nmcnasty \u2014 02/28/2022\nthe oppression is there to help them \ud83e\udd23\nrexmondo \u2014 02/28/2022\nExactly\nNow, actually you probably do want to consider the case where I didn\u2019t catch the error here but my caller wants to\nmcnasty \u2014 02/28/2022\nV2 \ud83e\udd37\nrexmondo \u2014 02/28/2022\nIt\u2019s actually really convenient in a program to let the higher levels of the program aggregate errors so you can logically centralize the user facing messages from those errors\nmcnasty \u2014 02/28/2022\ncontinuation is a nightmare\nI'm sorry I think I miss what you mean\nmaybe an example ?\nrexmondo \u2014 02/28/2022\nSo if I\u2019m going to create an api, I always put the error handler right where I pick the routes I want to call into, the fan out/fan in point\nThat way there\u2019s only one place to manage the communication back to the api caller, and I can keep a big list of error type->human readable message all in one spot\nIf you were to catch the errors right where they happen, you probably aren\u2019t in the right context to even know how this is going to get sent back to the api caller\nThe way we did this before was to put a synthetic continuation that gets called only when an error hook is not supplied that finds the caller and replies to it with an error that we copy from the original error\nYou could do the same thing in userland too, we just added it automatically if you didn\u2019t\nmcnasty \u2014 02/28/2022\nhmmm........ I think that is handled by promise chaining, or by crashing if an unhandled exception occurs. I'll try double check this with you whenever our next call occurs\nrexmondo \u2014 02/28/2022\nYeah as long as you can chain promises you can bubble errors by just providing your own bubble code\nmcnasty \u2014 02/28/2022\nI am currently passing the whole error itself\nso you get the genuine error being thrown, stack trace and all\nthere isn't much of the JVM that I haven't serialized in some way by now \ud83e\udd26\nrexmondo \u2014 02/28/2022\nHahaha\nThe other thing I played with when I was trying it is adding a chain trace in addition to the stack trace\nAs you hop back through the chains, adding them to the stack trace too\nmcnasty \u2014 02/28/2022\nhey that's a really good idea\nI'll put that in the backlog\nrexmondo \u2014 02/28/2022\nYeah, it\u2019s like getting the async frames in node, it\u2019s way more helpful than I expected\nmcnasty \u2014 02/28/2022\nmy dream is that along with those errors, we could give you a blockhash and you could fire up a tool that would recreate the exact situation that caused the error\nplus autogenerate some jest tests using these hashes as the start point, since hey its all as permanent as you want it \ud83e\udd37\nrexmondo \u2014 02/28/2022\nThat sounds real good\nmcnasty \u2014 02/28/2022\nbasically, fuck logs, especially in cloud environments\nreplay the whole app instead\nhonestly the size of the logs is usually so massive, and you're still not sure you captured everything you need\nrexmondo \u2014 02/28/2022\nI love love love the idea of all errors coming with everything you need to understand them\nAnd replay them\nmcnasty \u2014 02/28/2022\nand if its safe to do so, the general public should be able to replay them and fix them\ngo to sleep, some error happens, wake up - fixed already\nthey just own a small piece of your attribution\nI mean if you can repro the error by default, things should be much easier\nthat's often most of the struggle anyways\n#yoco you only crash once\nmcnasty \u2014 02/28/2022\nThat's actually crazy powerful now that I think about it in the context of onboarding noobs - their app throws an error, it auto generates an IPFS link to the blockhash, channelId, and action number, then we can replay it exactly in browser\nwelcome to the permanent errors web \ud83e\udd23\nrexmondo \u2014 02/28/2022\nits also a super powerful toolkit for interacting with foreign chains\nyou can trace all the way back to the foreign input\nmcnasty \u2014 02/28/2022\nyeah\nthat's a different set of tooling that I dream about tho\nlike each time you change something, replay all your foreign chain interactions and make sure you still give back the same results\noh wait sorry - you're talking about when you first encounter an error\nrexmondo \u2014 02/28/2022\nno impedance mismatch across the known set of interactions! thats amazing\nmcnasty \u2014 02/28/2022\nyeah, so you can actually force semver increments\nrexmondo \u2014 02/28/2022\ni meant it as like if their input causes my error, i can adapt my model of their system\nrexmondo \u2014 02/28/2022\nderived semver!\nmcnasty \u2014 02/28/2022\n\"hey we just replayed your code against everyone who ever called the last version, and some of the output was different so therefore your interface has changed - welcome to your new major version\"\nmcnasty \u2014 02/28/2022\n\ud83d\udc4d\nhopefully we can sell some of this, as semver verification as a service, or other such changeables\nrexmondo \u2014 02/28/2022\ni think its easily sellable\ndependency versioning is a nightmare\nmcnasty \u2014 02/28/2022\nso is repro\nbut solving both problems together should be quite liberating\nrepro is pretty much the heart of blockchain - we should be using it as a programming tool\nrexmondo \u2014 02/28/2022\n100%\nim just imagining a version bump process where the entire history of using the dependency is replayed using the new version and you can see the entire affected surface of your app\nmcnasty \u2014 02/28/2022\noh wow that would be super helpful\nthen you could even auto upgrade so long as nothing changed\nthen it gets fun, since we need staked pools to guarantee nothing sneaky made it in there\nthat's the exciting shit - politics, money, code all swirling in one big cauldron lol\nanyway I'm out for the day - catch you later \ud83d\udc4a\nrexmondo \u2014 02/28/2022\nPeace"))}u.isMDXComponent=!0}}]);