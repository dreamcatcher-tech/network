"use strict";(self.webpackChunk_dreamcatcher_tech_dreamcatcher_website=self.webpackChunk_dreamcatcher_tech_dreamcatcher_website||[]).push([[8966],{7352:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var n=a(7462),s=(a(7294),a(3905));a(1839);const i={},r="R22 Fast XState",o={unversionedId:"Requests/R22",id:"Requests/R22",title:"R22 Fast XState",description:"npm i fast-xstate",source:"@site/dust/Requests/R22.md",sourceDirName:"Requests",slug:"/Requests/R22",permalink:"/dust/Requests/R22",draft:!1,editUrl:"https://github.com/dreamcatcher-tech/dreamcatcher-tech.github.io/edit/master/website/dust/Requests/R22.md",tags:[],version:"current",frontMatter:{},sidebar:"dust",previous:{title:"R21 Small Topics",permalink:"/dust/Requests/R21"},next:{title:"R23 Email",permalink:"/dust/Requests/R23"}},l={},h=[{value:"Philosophy",id:"philosophy",level:3},{value:"Background",id:"background",level:3},{value:"Features provided by a higher order state chart",id:"features-provided-by-a-higher-order-state-chart",level:2},{value:"Interpreter state chart",id:"interpreter-state-chart",level:2},{value:"Could the core be a statechart too ?",id:"could-the-core-be-a-statechart-too-",level:2},{value:"Minimum subset of features required to implement all other features",id:"minimum-subset-of-features-required-to-implement-all-other-features",level:2},{value:"Debugging features",id:"debugging-features",level:2}],u={toc:h};function c(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"r22-fast-xstate"},"R22 Fast XState"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"npm i fast-xstate"),"\nXState interpreter with pure unadultered thread hogging speed"),(0,s.kt)("h3",{id:"philosophy"},"Philosophy"),(0,s.kt)("p",null,"The XState interpreter simply determines what order to call the user supplied code in, passing context between them all, in response to external events being inserted. This should be an extremely fast and lightweight process, but the current XState implementation carries significant overhead for high performance uses."),(0,s.kt)("p",null,"Debugging these functions is also difficult as seeing the state of the machine during previous states is hard, and with transient states is near impossible. We need a system that lets us use traditional debugging tools to quickly and clearly see what are the problems with our user supplied code, and in what order things have been called."),(0,s.kt)("h3",{id:"background"},"Background"),(0,s.kt)("p",null,"Over the past 18 months, XState has served us immensely well."),(0,s.kt)("p",null,"However, we have found the implementation lacking for our admitedly very specific needs, which are:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"As fast as possible execution"),(0,s.kt)("li",{parentName:"ol"},"Tracing by stepping thru all transitions, including transient transitions")),(0,s.kt)("p",null,"When we attempt to reuse the code of the current XState implementation, we are surpised that:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Some of the code files are large, making it difficult to decipher"),(0,s.kt)("li",{parentName:"ol"},"None of XState seems to be written in XState")),(0,s.kt)("p",null,"For our application, which is a blockchain that is written almost entirely using XState to manage the complexity of the project, we also have the ability to run XState machines inside of the blockchain itself."),(0,s.kt)("p",null,"This all begs the question: Can a small core of XState functionality be used to write all the extended functionality of XState in the XState language itself ?"),(0,s.kt)("p",null,"Benefits are:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Smaller core code"),(0,s.kt)("li",{parentName:"ol"},"Implementation can leverage the same tools XState applications do, such as visualization, testing"),(0,s.kt)("li",{parentName:"ol"},"Contributors to the project, who will most likely be using XState for their own projects, will immediately understand how the system works"),(0,s.kt)("li",{parentName:"ol"},"Possibly greater speed, with configurable thread hogging capability, when raw speed matters"),(0,s.kt)("li",{parentName:"ol"},"All the tools of XState can be brought to bear on the XState project itself"),(0,s.kt)("li",{parentName:"ol"},"writing the core and using XState become close to the same thing, meaning core developer time is spent more on the usage of XState, making them heavy power users, rather than two separate software disciplines taking place, with core more focused on conventional development, and users more focused on XState language"),(0,s.kt)("li",{parentName:"ol"},"In the visual debugger, can present the underlying state machines, so users can understand what is happening under the hood, and can express bugs easier"),(0,s.kt)("li",{parentName:"ol"},"The mere fact that it runs proves the utility of XState and the correctness of the implementation"),(0,s.kt)("li",{parentName:"ol"},"Dicussion can focus more on what is the best statechart for processing the Xstate language ?"),(0,s.kt)("li",{parentName:"ol"},"A degree of self provability - self proving that complex tasks can be handled, that the tooling and architectural skills are present within the process to use it for complex things"),(0,s.kt)("li",{parentName:"ol"},"Add XState to the list of projects using XState - this is not true currently and it should be the largest user of its own produce")),(0,s.kt)("h2",{id:"features-provided-by-a-higher-order-state-chart"},"Features provided by a higher order state chart"),(0,s.kt)("p",null,"The HOSC expands on the features of the core by running at the start and at every transition, in effect decorating the core behaviour. Seeing statecharts visually is about the most illuminating thing a programmer could hope for, and so by jumping into statechart land as early as possible, we can gain these benefits for the majority of the XState codebase."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"invoke"),(0,s.kt)("li",{parentName:"ol"},"parallel states"),(0,s.kt)("li",{parentName:"ol"},"Format checking of machine and config"),(0,s.kt)("li",{parentName:"ol"},"Actors"),(0,s.kt)("li",{parentName:"ol"},"Error checking and handling"),(0,s.kt)("li",{parentName:"ol"},"Transformation of shorthand expressions into core format"),(0,s.kt)("li",{parentName:"ol"},"History"),(0,s.kt)("li",{parentName:"ol"},"Jumping across states using id's"),(0,s.kt)("li",{parentName:"ol"},"Statecharts ? Use core for only flat state machines ?")),(0,s.kt)("h2",{id:"interpreter-state-chart"},"Interpreter state chart"),(0,s.kt)("p",null,"This statechart calls the HOSC to do pure transition functions, then it takes the result and executes all the actions, updating the context."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Timers"),(0,s.kt)("li",{parentName:"ol"},"start, stop, pause of running interpreter"),(0,s.kt)("li",{parentName:"ol"},"receiving external events")),(0,s.kt)("h2",{id:"could-the-core-be-a-statechart-too-"},"Could the core be a statechart too ?"),(0,s.kt)("p",null,"Transition to next node, resolve current node, then lob up an action to self to cause the processing of each step ?"),(0,s.kt)("p",null,"In effect, there would be no single program that could execute the core statechart, just something to start the operation, ways to process each node, then actions send to self to move the system forwards."),(0,s.kt)("h2",{id:"minimum-subset-of-features-required-to-implement-all-other-features"},"Minimum subset of features required to implement all other features"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"receieve action"),(0,s.kt)("li",{parentName:"ol"},"always transition"),(0,s.kt)("li",{parentName:"ol"},"conditional transition"),(0,s.kt)("li",{parentName:"ol"},"transition actions"),(0,s.kt)("li",{parentName:"ol"},"single dimensional transitions\nWith these features, can write a statechart that when executed")),(0,s.kt)("h2",{id:"debugging-features"},"Debugging features"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Each transition, along with exec() to call all functions, should contain a list of function names in the order they will be called in, so users can see what order their code will be called in each transition"),(0,s.kt)("li",{parentName:"ol"},"Debugging for each piece of user code, where the call params and output result can be traced"),(0,s.kt)("li",{parentName:"ol"},"each subsequent call to exec actually takes place within the last one, so debugger can walk the stack to see values of execution")))}c.isMDXComponent=!0}}]);